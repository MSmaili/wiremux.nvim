*wiremux.txt*  *wiremux*  Send text from Neovim to tmux targets

==============================================================================
CONTENTS                                                        *wiremux-contents*

1. Introduction .................................. |wiremux-introduction|
2. Tutorial  ..................................... |wiremux-tutorial|
3. How-to guides .................................. |wiremux-howto|
4. Configuration .................................. |wiremux-configuration|
   4.1 Filters .................................... |wiremux-filters|
5. Placeholders (context) ......................... |wiremux-placeholders|
6. Commands ....................................... |wiremux-commands|
7. Lua API ........................................ |wiremux-api|
8. Statusline ..................................... |wiremux-statusline|
9. Troubleshooting ................................ |wiremux-troubleshooting|
10. Explanation / design notes .................... |wiremux-explanation|

==============================================================================
1. INTRODUCTION                                                *wiremux-introduction*

wiremux is a small Neovim plugin that sends text to tmux panes/windows.

It was built for an AI workflow: keep an assistant like `opencode` or
`claudecode` running in a dedicated tmux pane, then send it context (selection,
diagnostics, git diff, quickfix) with a keymap.

wiremux is inspired by folke/sidekick.nvim, but aims to stay simpler and more
tmux-first.

Features:

  - Create/focus/close named tmux targets
  - Send text (or pick from a list of prompts)
  - Expand context placeholders like {file}, {position}, {diagnostics_all}
  - Store instance metadata in tmux (survives Neovim restarts)
  - Lazy loaded (near zero startup cost)

Requirements:

  - Neovim 0.10+
  - tmux 3.0+ recommended
  - Neovim must run inside tmux

==============================================================================
2. TUTORIAL                                                    *wiremux-tutorial*

The simplest way to use wiremux is:

  1) Define a target that runs your AI assistant
  2) Map a key to send prompts with placeholders

Define targets:
>lua
  require("wiremux").setup({
    targets = {
      definitions = {
        opencode = {
          cmd = "opencode",
          kind = "pane",
          split = "vertical",
          shell = false, -- recommended if you want to
                         -- close/kill pane/window when closing
          label = "OpenAI", -- custom display name (string or function)
          title = "AI-OpenAI", -- tmux window name (for kind="window")
        },
        claudecode = {
          cmd = "claudecode",
          kind = "window",
          split = "horizontal",
          label = "Claude",
          title = "AI-Claude",
        },
      },
    },
  })
<

Send a prompt to your target:
>lua
  require("wiremux").send("Explain {position}\n\n{this}")
<

Pick from a custom prompt list:
>lua
  vim.keymap.set({ "n", "x" }, "<leader>ap", function()
    require("wiremux").send({
      { label = "Review changes", value = "Can you review my changes?\n{changes}" },
      { label = "Fix diagnostics", value = "Fix {file}\n{diagnostics_all}" },
      { label = "Fix quickfix", value = "Help me fix these:\n{quickfix}" },
    })
  end, { desc = "Wiremux: Select prompt" })
<

SendItem fields ~

| Field     | Type                    | Description                              |
|-----------|-------------------------|------------------------------------------|
| value     | string                  | Text/command to send (required)          |
| label     | string (optional)       | Display name in picker                   |
| title     | string (optional)       | Custom tmux window / zellij tab name     |
| submit    | boolean (optional)      | Auto-submit after sending                |
| visible   | boolean or function     | Show/hide item based on condition        |

Commands with auto-submit:
>lua
  require("wiremux").send({
    { label = "Run tests", value = "npm test", submit = true },
    { label = "Run dev", value = "npm run dev", submit = true },
  })
<

Conditional visibility:
>lua
  require("wiremux").send({
    {
      label = "TypeScript check",
      value = "npx tsc --noEmit",
      submit = true,
      visible = function() return vim.bo.filetype == "typescript" end
    },
    {
      label = "Test selection",
      value = "jest -t '{selection}'",
      visible = function()
        return require("wiremux.context").is_available("selection")
      end
    },
  })
<

Dynamic labels for targets ~

You can use a function for `label` to create dynamic display names:
>lua
  require("wiremux").setup({
    targets = {
      definitions = {
        devserver = {
          cmd = "npm run dev",
          kind = "window",
          title = "Dev-Server",
          -- Dynamic label shows running command
          label = function(inst, index)
            local cmd = inst.running_command or "idle"
            return string.format("Dev #%d [%s]", index, cmd)
          end,
        },
      },
    },
  })
<
The `label` function receives:
- `inst`: Instance info (id, target, kind, running_command, etc.)
- `index`: Instance number (1, 2, 3...) for targets with multiple instances

==============================================================================
3. HOW-TO GUIDES                                                   *wiremux-howto*

3.1 Run a tool directly (no shell wrapper)                *wiremux-howto-shell-false*

By default, wiremux creates a pane/window and then types the command into it.
That is convenient for long-running shells.

If you want to run a program directly (and have tmux close the pane when the
program exits), set `shell = false`:
>lua
  require("wiremux").setup({
    targets = {
      definitions = {
        ai_direct = { cmd = "opencode", kind = "pane", shell = false },
      },
    },
  })
<

3.2 Use send_motion (operator)                                   *wiremux-howto-send-motion*

`send_motion()` sets `operatorfunc` and returns `g@`. The usual pattern is an
expr-mapping:
>lua
  vim.keymap.set({ "n", "x" }, "ga", function()
    return require("wiremux").send_motion()
  end, { expr = true, desc = "Wiremux: Send motion" })
<

Example usage:

  - Normal mode: press `ga` then a motion/textobject (for example `ip`)
     sends paragraphs
  - Visual mode: select text, then press `ga`
     sends selection

==============================================================================
4. CONFIGURATION                                              *wiremux-configuration*

Configure with: >lua
  require("wiremux").setup({
    -- options here
  })
<

Complete example:
>lua
  require("wiremux").setup({
    picker = {
      adapter = "fzf-lua", -- "fzf-lua" | "vim.ui.select" | custom function
      instances = {
        filter = function(inst, state)  -- optional, default: filter by origin
          return inst.origin == state.origin_pane_id
        end,
        sort = function(a, b)  -- optional, default: sort by recency
          return (a.last_used_at or 0) > (b.last_used_at or 0)
        end,
      },
      targets = {
        filter = nil,  -- optional, no default filter
        sort = nil,    -- optional, no default sort
      },
    },
    targets = {
      definitions = {
        opencode = {
          cmd = "opencode",
          kind = "pane",
          split = "vertical",
          label = "OpenAI",  -- display name in picker (string or function)
          title = "AI-OpenAI", -- tmux window name (for kind="window")
          shell = false,
        },
        claudecode = {
          cmd = "claudecode",
          kind = "pane",
          split = "horizontal",
          label = "Claude",
          title = "AI-Claude",
        },
      },
    },
  })
<

Top-level options ~

*wiremux-config-log-level*
log_level           (string, default: "warn")
                    "off" | "error" | "warn" | "info" | "debug"

*wiremux-config-targets*
targets             (table)
                    Contains `definitions`.

*wiremux-config-targets-definitions*
targets.definitions (table<string, definition>)
                    Map of target names to their definitions.

Target definition fields ~

*wiremux-config-definition-cmd*
cmd                 (string|nil)
                    Command to run in the target.

*wiremux-config-definition-kind*
kind                (string|table, default: "pane")
                    "pane" or "window"
                    table (e.g., {"pane", "window"}) = prompt to choose at runtime

*wiremux-config-definition-split*
split               (string, default: "horizontal")
                    For panes: "horizontal" or "vertical"

*wiremux-config-definition-label*
label               (string|function|nil)
                    Custom display name for the target.
                    If a function: `fun(inst, index): string` for dynamic labels.

*wiremux-config-definition-title*
title               (string|nil)
                    Custom tmux window name when creating.
                    Only used when `kind = "window"`.
                    Defaults to `label` (if string) or target name.

*wiremux-config-definition-shell*
shell               (boolean, default: true)
                    true: create pane, then type cmd
                    false: pass cmd directly to tmux (pane closes when cmd exits)

Action defaults ~

*wiremux-config-actions*
actions             (table)
                    Default behavior for send/focus/close.

*wiremux-config-action-behavior*
actions.*.behavior  (string)
                    "pick" - show picker
                    "last" - use last target
                    "all"  - apply to all targets

*wiremux-config-action-submit*
actions.send.submit (boolean)
                    Send Enter after pasting text.

*wiremux-config-action-focus*
actions.*.focus     (boolean)
                    Focus target after action.

Picker configuration ~

*wiremux-config-picker*
picker              (table)
                    Picker configuration.

*wiremux-config-picker-adapter*
picker.adapter      (string|function|nil)
                    Picker to use. nil = auto-detect (fzf-lua preferred)
                    "fzf-lua" | "vim.ui.select" | custom function

*wiremux-config-picker-instances*
picker.instances    (table)
                    Configuration for instance filtering and sorting.

*wiremux-config-picker-instances-filter*
picker.instances.filter (string|function)
                    "origin" - show targets from current Neovim instance
                    "cwd" - show targets from current working directory  
                    "global" - show all targets
                    function - custom filter function

*wiremux-config-picker-instances-sort*
picker.instances.sort (string|function, default: "recency")
                    "recency" - sort by most recent first
                    function - custom sort function

*wiremux-config-picker-targets*
picker.targets      (table)
                    Configuration for target definition filtering and sorting.

*wiremux-config-picker-targets-filter*
picker.targets.filter (string|function, default: "global")
                    "global" - show all target definitions
                    function - custom filter function

*wiremux-config-picker-targets-sort*
picker.targets.sort (string|function, default: "name")
                    "name" - sort alphabetically by name
                    function - custom sort function

Other options ~

*wiremux-config-context*
context.resolvers   (table<string, function>)
                    Custom placeholder functions.
                    See |wiremux-placeholders|.

==============================================================================
4.1 FILTERS                                                    *wiremux-filters*

Filters control which targets appear in pickers. Configure them in the picker
section. This is useful when you have multiple Neovim instances or want to
share AI assistants across projects.

Filter functions receive:
- `inst` (Instance): { id, target, origin, origin_cwd, kind, last_used }
- `state` (State): { origin_pane_id, last_used_target_id, instances }

Three common strategies:

1. BY ORIGIN (default) - isolated per Neovim instance ~

Only show targets created from the current Neovim pane. This keeps your AI
assistant private to your current editor instance.
>lua
  require("wiremux").setup({
    picker = {
      instances = {
        filter = function(inst, state)
          return inst.origin == state.origin_pane_id
        end,
      },
    },
  })
<

2. BY WORKING DIRECTORY - shared within a project ~

Show all targets created from the same directory. Useful when you want one
AI assistant per project, shared across multiple Neovim instances in the
same project.
>lua
  require("wiremux").setup({
    picker = {
      instances = {
        filter = function(inst, state)
          return inst.origin_cwd == vim.fn.getcwd()
        end,
      },
    },
  })
<

3. NO FILTER - global shared targets ~

Show all targets regardless of where they were created. Useful if you want
one global AI assistant for everything.
>lua
  require("wiremux").setup({
    picker = {
      instances = {
        filter = nil,  -- no filter, show all
      },
    },
  })
<

Custom sorting ~

Control the order targets appear in pickers:
>lua
  require("wiremux").setup({
    picker = {
      instances = {
        -- Default: sort by recency (most recent first)
        sort = function(a, b)
          return (a.last_used_at or 0) > (b.last_used_at or 0)
        end,
      },
      targets = {
        -- Default: no sorting (insertion order)
        -- Example: sort alphabetically
        sort = function(a, b)
          return a < b
        end,
      },
    },
  })
<

Per-action filters ~

You can also override filters for specific actions using `opts.filter`:
>lua
  -- For send: only show pane targets (not windows)
  require("wiremux").send("text", {
    filter = {
      instances = function(inst, state)
        return inst.kind == "pane"
      end,
    },
  })
<

==============================================================================
5. PLACEHOLDERS (CONTEXT)                                     *wiremux-placeholders*

wiremux expands `{placeholders}` before sending.

Built-ins:

  {file}            current buffer path
  {filename}        basename of {file}
  {position}        file:line:col (1-based line/col)
  {line}            current line text
  {selection}       visual selection (empty if not in visual mode)
  {this}            {position} plus {selection} when available
  {diagnostics}     diagnostics on current line
  {diagnostics_all} all diagnostics in current buffer
  {quickfix}        formatted quickfix list
  {buffers}         list of listed, loaded buffers
  {changes}         git diff HEAD -- {file} (or "No changes")

Custom resolvers:
>lua
  require("wiremux").setup({
    context = {
      resolvers = {
        git_branch = function()
          local result = vim.system({ "git", "branch", "--show-current" }, { text = true }):wait()
          return result.code == 0 and vim.trim(result.stdout) or nil
        end,
      },
    },
  })
<

Checking placeholder availability ~

Use `context.is_available()` to check if a placeholder has a value:

>lua
  local context = require("wiremux.context")
  if context.is_available("selection") then
    -- selection is not empty
  end
<

This is useful for conditional visibility in SendItem:

>lua
  {
    label = "Test selection",
    value = "jest -t '{selection}'",
    visible = function()
      return require("wiremux.context").is_available("selection")
    end
  }
<

==============================================================================
6. COMMANDS                                                      *wiremux-commands*

The main entry point is the `:Wiremux` command.

                                                           *:Wiremux*
:Wiremux {subcommand} ...

Subcommands:

                                                           *:Wiremux-send*
:Wiremux send {text...}
        Send text to a target. If there are multiple targets, a picker may be
        shown depending on behavior.

                                                      *:Wiremux-send-motion*
:Wiremux send-motion
        Prepare operator-pending send. For most users, mapping
        `require("wiremux").send_motion()` with `{ expr = true }` is the
        intended usage. See |wiremux-howto-send-motion|.

                                                          *:Wiremux-focus*
:Wiremux focus
        Focus a target.

                                                         *:Wiremux-create*
:Wiremux create
        Create a new target from configured definitions.

                                                          *:Wiremux-close*
:Wiremux close
        Close a target pane/window.

                                                         *:Wiremux-toggle*
:Wiremux toggle
        Toggle "visibility" for the last-used target.
        - pane targets: toggles zoom
        - window targets: switches to the window

:==============================================================================
7. LUA API                                                          *wiremux-api*

The Lua module is `require("wiremux")`.

                                                     *wiremux.setup()*
wiremux.setup({opts})
        Configure wiremux.

                                                     *wiremux.send()*
wiremux.send({text|items}, {opts})
        Send a string, or pick from a list of items.

        Items are { name = string, text = string }.

                                                     *wiremux.focus()*
wiremux.focus({opts})
        Focus a target.

                                                    *wiremux.create()*
wiremux.create({opts})
        Create a target from definitions.

                                                     *wiremux.close()*
wiremux.close({opts})
        Close a target.

                                                    *wiremux.toggle()*
wiremux.toggle({opts})
        Toggle visibility for the last-used target.

                                                *wiremux.send_motion()*
wiremux.send_motion({opts})
        Set operatorfunc and return "g@".

==============================================================================
8. STATUSLINE                                          *wiremux-statusline*

                                                 *wiremux.statusline*
wiremux.statusline
        Display active wiremux targets in your statusline. See
        |wiremux-statusline| for detailed documentation.

                                            *wiremux.statusline.get_info()*
wiremux.statusline.get_info()
        Returns information about active targets. Non-blocking, returns
        cached data. On first call initializes background timer.

        Returns { loading, count, last_used }

                                            *wiremux.statusline.component()*
wiremux.statusline.component()
        Returns a statusline component function. Works with any statusline
        plugin (lualine, heirline, feline, etc.). Usage:
>lua
        { require("wiremux").statusline.component() }
<

                                            *wiremux.statusline.refresh()*
wiremux.statusline.refresh()
        Force immediate refresh (blocking).

USAGE                                                   *wiremux-statusline-usage*

Lualine component (simplest way):
>lua
    {
      require("wiremux").statusline.component(),
      padding = { left = 1, right = 1 },
    }
<

Custom statusline with get_info():
>lua
    local info = require("wiremux").statusline.get_info()
    if info.count == 0 then
        return ""
    end
    return string.format("[tmux:%d]", info.count)
<

HOW IT WORKS                                       *wiremux-statusline-design*

The statusline module uses a smart caching strategy:

1. Lazy loading — Nothing loaded until get_info() or component() called
2. Async updates — First call triggers async fetch, returns loading state
3. Operation sync — Operations update cache directly without IPC
4. Background refresh — 30s timer catches external tmux changes
5. Debouncing — 500ms debounce prevents double-fetches
6. FocusGained autocmd — Refreshes when returning to Neovim

This gives instant status updates with minimal IPC calls.

==============================================================================
9. TROUBLESHOOTING                                          *wiremux-troubleshooting*

If things do not work:

  - Make sure Neovim runs inside tmux (check `$TMUX`).
  - Run `:help wiremux`.
  - If pickers are not showing, try without optional pickers to confirm the
    fallback works (`vim.ui.select`).

==============================================================================
10. EXPLANATION / DESIGN NOTES                                  *wiremux-explanation*

State is stored in tmux (pane variables like `@wiremux_*`), not in Neovim.
That makes instances survive Neovim restarts and lets multiple Neovim
instances share the same targets.

vim:tw=78:ts=8:ft=help:norl:
